---
title: "Bootstrap testing of procrustes hypothesis"
author: "Charles Zheng"
date: "12/16/2015"
output: html_document
---

Let $X$ and $Y$ be indepedent $p \times q$ random matrices, with distributions $F$ and $G$ respectively.
Let $A = E[X]$ and $B = E[Y]$.
The goal is to test the *Procrustes hypothesis*

$$
H_0: A^T A = B^T B
$$

or equivalently, that there exists $\Omega$ orthogonal such that $\Omega A = B$.
The data consists of i.i.d. indpendent realizations $X^{(1)}, ..., X^{(n_x)}$ and $Y^{(1)},..., Y^{(n_y)}$.

*Example:* 
We are testing the congruence of two physical objects.  The $q$ columns of $A$ consist of the true positions of $q$ labelled landmarks on the first object, measured according to some orthogonal coordinate system.  The $q$ columns of $B$ give the positions of the corresponding landmarks of the second object, measured using a different orthogonal system compared to the first.  Both sets of positions are centered and standardized using an $(q + 1)$ th landmark which is used to define the origin.  $A$ and $B$ are not observed directly; instead, they must be inferred from unbiased, noisy measurements $X$ and $Y$ respectively.

The situation is depicted in Figure 1.

```{r, fig.height=4.4, fig.width=6.6}
library(pracma)
shape.inner <- matrix(c(0,0, 1,-2, -1,-2, 0,0), 2, 4)
shape.outer <- matrix(c(0,4, 3,-2, 3,-4, -3,-4, -3,-2, 0,4), 2, 6)
A <- cbind(shape.inner[, -4], shape.outer[, -1])
theta <- pi/3; Omega0 <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), 2, 2)
B <- Omega0 %*% A
par(mfrow=c(1,2),oma = c(0, 0, 2, 0))
plot(NA, NA, xlim = c(-5, 5), ylim = c(-5, 5), ann = FALSE); title("A")
for (i in 1:8) text(t(A[, i]), paste(i-1))
polygon(t(shape.inner), lty = 2); polygon(t(shape.outer), lty = 2)
plot(NA, NA, xlim = c(-5, 5), ylim = c(-5, 5), ann = FALSE); title("B")
polygon(t(Omega0 %*% shape.inner), lty = 2); polygon(t(Omega0 %*% shape.outer), lty = 2)
for (i in 1:8) text(t(B[, i]), paste(i-1))
mtext("Figure 1", outer = TRUE, cex = 1.5)
```

# Procrustes analysis

A natural analysis of this problem is as follows.
Obtain $\hat{A} = \bar{X}$, and $\hat{B} = \bar{Y}$.
Then look for a rotation matrix $R$ which minimizes

$$
||R\hat{A} - \hat{B}||_F^2.
$$

The solution to the above optimization problem was derived by Schonemann (1964).
Having obtained the SVD decomposition
$$
\hat{B}\hat{A}^T = V D U^T,
$$
the optimal rotation is given by
$$
R = VU^T.
$$

# Bootstrap Test

The data is given in the form of two samples, $X^{(1)}, ..., X^{(n_x)}$ and $Y^{(1)},..., Y^{(n_y)}$.
In order to conveniently apply resampling methods, let us adopt the following one-sample sampling model:
the data is given in the form of ordered pairs $(0, X^{(1)}), ..., (0, X^{(n_x)}), (1, Y^{(1)}),..., (1, Y^{(n_y)})$.  Then any one-sample resampling method can be applied to the data.

The data model is given in code as follows. 


`procrustes_data_model_` is a function which takes as inputs:

 * The true parameters $A$, $B$
 * A covariance matrix $\Sigma_X$ for the noise in each column of $X$.
 * A covariance matrix $\Sigma_Y$

The output is a function `sampler(nX, nY)`, which produces $n_X$ observations of $X$ and $n_Y$ observations of $Y$ (vectorized).  The dimensions $p$ and $q$ are stored as global variables.

```{r}
library(MASS)
p <- 3
q <- 10
A <- randn(p, q); B <- randn(p, q)
SigmaX <- cov(randn(2*p, p)); SigmaY <- cov(randn(2 * p, p))

f2 <- function(x, y = 0) sum((x-y)^2)

procrustes_data_model_ <- function(A, B, SigmaX = eye(p), SigmaY = eye(p)) {
  vecA <- as.numeric(A)
  vecB <- as.numeric(B)
  sampler <- function(nX, nY) {
    rawX <- repmat(vecA, nX, 1)
    temp <- t(mvrnorm(nX * q, rep(0, p), SigmaX))
    rawX <- t(t(rawX) + as.numeric(temp))
    rawY <- repmat(vecB, nY, 1)
    temp <- t(mvrnorm(nY * q, rep(0, p), SigmaY))
    rawY <- t(t(rawY) + as.numeric(temp))
    ans <- rbind(cbind(0, rawX), cbind(1, rawY))
    ans
  }
  sampler
}

## computes Ahat and Bhat
sample_moments <- function(dat) {
  rawX <- dat[dat[,1] == 0, -1, drop = FALSE]
  rawY <- dat[dat[,1] == 1, -1, drop = FALSE]  
  Ahat <- matrix(colMeans(rawX), p, q)
  Bhat <- matrix(colMeans(rawY), p, q)
  list(Ahat = Ahat, Bhat = Bhat)
}

sampler <- procrustes_data_model_(A, B, SigmaX, SigmaY)
dat <- sampler(100, 200)
mus <- sample_moments(dat)
f2(mus$Ahat, A)
f2(mus$Bhat, B)
```


Define the following multivariate test statistics $T$ and $D$:

$$
T = \hat{A} - U V^T \hat{B}.
$$

$$
D = \hat{A}^T \hat{A} - \hat{B}^T\hat{B}.
$$

The test statistics are given in code as follows
```{r}
```


 * A single hypothesis test, $||T||_F^2 = 0$.
 * Multiple hypothesis tests, $T_{ij} = 0$.








