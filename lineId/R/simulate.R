

#' Generates normal matrix with both row and column correlations
#' 
#' Multivariate normal with covariance \code{Sigma_e \%x\% Sigma_t}
#' @param Sigma_e (p x p) matrix, covariances between columns (or within a row)
#' @param Sigma_t (T x T) matrix, covariances between rows (or within a column)
#' @return A (T x p) matrix
#' @export
mvrnorm2 <- function(Sigma_e, Sigma_t) {
  a_e <- sqrtm(Sigma_e)
  a_t <- sqrtm(Sigma_t)
  a_t %*% randn(dim(Sigma_t)[1], dim(Sigma_e)[1]) %*% a_e
}

#' Generates parameters for a Bayesian multivariate regression model
#' 
#' Generates covariance matrices for X, E, and B,
#' then generates X, B, and test set X.
#' See \code{\link{gen_data}} to generate response Y.
#' \itemize{
#'   \item Covariance matrices are appropriated scaled Wishart matrices.
#'   \item \code{Sigma_X} generated with \code{W_X * pX} degrees of freedom.
#'   \item \code{Sigma_e} generated with \code{W_e * pY} degrees of freedom.
#'   \item \code{Sigma_t} generated as autoregressive covariance with parameter \code{rho_t}.
#'   \item \code{Sigma_b} diagonal with scaled (mean 1) chi-squared elements.
#'   \item Rows of \code{X} are normal \code{Sigma_X}.
#'   \item Noise matrix \code{E} has covariance \code{Sigma_t \%*\% Sigma_e}.
#' }
#' @param n Training set size
#' @param pY Dimension of response
#' @param pX Dimension of covariate
#' @param W_X Degrees of freedom multiplier for \code{Sigma_X}
#' @param s_e Noise standard error multipler
#' @param s_b Signal size multiplier
#' @param df_b Degrees of freedom for elements of \code{Sigma_b}
#' @param W_e Degrees of freedom multiplier for \code{Sigma_e}
#' @param rho_t Autocorrelation parameter for \code{Sigma_t}
#' @param L Number of test set candidates
#' @param n_te Test set size
#' @return A list with elements \code{X, X_te, B, Sigma_b, Sigma_e,
#' Sigma_t, n_te}
#' @import MASS
#' @export
gen_params <- function(n=30, pY= 60, pX= 70,
                       W_X= 2, s_e= 10, s_b = 1, df_b = 2,
                       W_e= 2, rho_t = 0,
                       L= 100, n_te= 10, ...) {
  if (W_X == Inf) {
    Sigma_X <- eye(pX)
  } else {
    Sigma_X <- cov(randn(W_X * pX, pX))    
  }
  if (W_e == Inf) {
    Sigma_e <- s_e * eye(pY)
  } else {
    Sigma_e <- s_e * cov(randn(W_e * pY, pY))
  }
  if (rho_t == 0) {
    Sigma_t <- eye(n)
  } else {
    Sigma_t <-  exp(log(rho_t) * abs(row(eye(n)) - col(eye(n))))
  }
  if (df_b < Inf) {
    s0s <- s_b^2 * rchisq(pY, df_b)/df_b    
  } else {
    s0s <- s_b^2 * rep(1, pY)
  }
  Sigma_b <- diag(s0s)
  dSigma_B <- rep(s0s, each = pX)
  Bvec <- sqrt(dSigma_B) * rnorm(pY * pX)
  B0 <- matrix(Bvec, pX, pY)
  X <- mvrnorm(n, mu = rep(0, pX), Sigma = Sigma_X)
  X_te <- mvrnorm(L, mu = rep(0, pX), Sigma = Sigma_X)
  list(X = X, X_te = X_te, B = B0, Sigma_b = Sigma_b, 
       Sigma_e = Sigma_e, Sigma_t = Sigma_t, n_te = n_te)  
}

#' Generates data for a Bayesian multivariate regression model
#' 
#' See \code{\link{gen_params}} to generate X, B and covariance matrices
#' @param X Design matrix for training set
#' @param X_te Design matrix for test set
#' @param B coefficient matrix
#' @param Sigma_b Prior covariance of B
#' @param Sigma_e Prior within-row covariance of E
#' @param Sigma_t Prior within-column covariance of E
#' @param n_te Number of rows X_te to subsample to produce training set
#' @return List with elements \code{X, Y, X_te, i_chosen, y_star, B,
#' Sigma_b, Sigma_e, Sigma_t}.  \code{y_star} are test set responses
#' while \code{i_chosen} are the indices corresponding rows of \code{X_te}.
#' @import MASS
#' @export
gen_data <- function(X, X_te, B, Sigma_b = NULL,
                     Sigma_e, Sigma_t, n_te, ...) {
  n <- dim(X)[1]
  L <- dim(X_te)[1]
  pX <- dim(X)[1]
  pY <- dim(B)[2]
  Y <- X %*% B + mvrnorm2(Sigma_e, Sigma_t)
  i_chosen <- sample(L, n_te, TRUE)
  y_star <- X_te[i_chosen, , drop = FALSE] %*% B +  mvrnorm(n_te, rep(0, pY), Sigma_e)
  list(X = X, Y = Y, X_te = X_te, i_chosen = i_chosen, y_star = y_star, B = B,
       Sigma_b = Sigma_b, Sigma_e = Sigma_e, Sigma_t = Sigma_t)
}


#' Extracts observed data from a list generated by gen_data
#' 
#' Use with \code{do.call}
#' @export
#' @examples
#' pars <- gen_params()
#' dat <- do.call(gen_data, pars)
#' obs <- do.call(obs_data_filter, dat)
obs_data_filter <- function(X, X_te, Y, y_star, ...)
  list(X = X, X_te = X_te, Y = Y, y_star = y_star)


